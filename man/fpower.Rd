% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scale_folded_power.R
\name{fpower}
\alias{fpower}
\title{Re-express proportions using the folded power transformation}
\usage{
fpower(x, lambda = 1, scaling = "plus_minus_1")
}
\arguments{
\item{x}{A numeric vector of scores in the unit interval [0,1]; 0 and 1 are allowed but throw an error message when lambda = 0}

\item{lambda}{Numeric value of the power transformation, which can range between 0 (limiting case: logit transformation) and 1 (no transformation)}

\item{scaling}{Character string indicating whether scores should be re-expressed to the [-1, 1] interval (\code{plus_minus_1}) or allowed to stretch beyond these limits (\code{free})}
}
\value{
A numeric vector
}
\description{
This function takes as input a vector of proportions (or, more generally, scores in the unit interval [0,1]) and re-expresses them using Tukey's folded power transformation. It allows the user to decide whether the transformed scores should be mapped to the [-1, +1] interval (default), or whether they may extend beyond these limits.
}
\details{
This function allows the user to apply a variety of folded power transformations to quantities bounded between 0 and 1. Different values may be specified for the power of the transformation (\eqn{\lambda} \code{lambda}), but only powers between 0 and 1 are supported. Two versions of the folded power transformation are available. The first maps transformed values to the [-1, +1] interval:

\eqn{x^\lambda - (1-x)^\lambda}

The second version does not impose these limits:

\eqn{(x^\lambda - (1-x)^\lambda) / \lambda}

For \code{lambda} equal to 0, the logit transformation is implemented as a limiting case; note that input scores of 0 and 1 are not allowed when \code{lambda} is set to 0
\code{lambda} = 0.14 gives a close approximation to the probit transformation (see Fox 2016: 74) while accepting input score of 0 and 1
\code{lambda} = 1/3 implements folded cube roots
\code{lambda} = 0.41 gives a close approximation to the arcsine-square-root (or angular) transformation (see Fox 2016: 74)
\code{lambda} = 0.5 implements folded roots
}
\examples{
fpower(
  seq(0, 1, .1),
  lambda = .14,
  scaling = "plus_minus_1")
}
\author{
Lukas Soenning
}
